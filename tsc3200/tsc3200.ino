
#include <timer.h>  // https://github.com/contrem/arduino-timer
#define S0     6    // The stronger the reflected light from the surface of the object, the higher the square wave frequency generated by the built-in oscillator of the TCS3002D.
#define S1     5    // The combination of S0 and S1 determines the output signal frequency scale factor, and the scale factor is 2%.                 
                    // The ratio factor is the ratio of the output signal frequency of the TCS3200 sensor OUT pin to its built-in oscillator frequency.
                 
#define S2     4    // The combination of S2 and S3 determines which red, green, and blue rays pass through the filter.
#define S3     3
#define OUT     2   // The TCS3200 color sensor output signal is connected to the Arduino interrupt 0 pin and triggers a pulse signal interrupt.                  
                    // Record the number of pulses of the TCS3200 output signal in the interrupt function

int   g_count = 0;  // Calculate the number of pulses corresponding to the reflected light intensity of the TCS3200 color sensor output signal
                    // The array is used to store the number of pulses of the TCS3200 output signal within 1 s. It is multiplied by the RGB scale factor to be the RGB standard value.
int   g_array[3];
int   g_flag = 0;   // Filter mode selection sequence flag
float g_SF[3];      // Converts the number of pulses from the TCS3200 output signal to the RGB scale factor of the RGB standard value
 
auto timer = timer_create_default();

void TSC_Init()
{
  // Set the scale factor of the built-in oscillator square wave frequency of the TCS3002D to its output signal frequency to be 2%.
  /*
  pinMode(S0, OUTPUT);
  pinMode(S1, OUTPUT);
  digitalWrite(S0, LOW);
  digitalWrite(S1, HIGH);
  */

  // Initialize the input and output modes of each control pin of the TSC3200
  pinMode(S2, OUTPUT);
  pinMode(S3, OUTPUT);
  pinMode(OUT, INPUT);
}
 
// Select the filter mode and decide which red, green, and blue light will pass through the filter.
void TSC_FilterColor(int Level01, int Level02)
{
  if(Level01 != 0)
    Level01 = HIGH;
 
  if(Level02 != 0)
    Level02 = HIGH;
 
  digitalWrite(S2, Level01); 
  digitalWrite(S3, Level02); 
}

// Interrupt function, calculate the number of pulses of the TCS3200 output signal
void TSC_Count()
{
  g_count ++ ;
}

// The timer interrupt function, after every 1 s interrupt, the red, green and blue light of the time is passed through the filter.
// The number of TCS3200 output signal pulses is stored in the corresponding element variable of the array g_array[3].
void TSC_Callback()
{
  switch(g_flag)
  {
    case 0:
         Serial.println("->WB Start");
         TSC_WB(LOW, LOW);  // Select the mode that lets red light pass through the filter
         break;
    case 1:
         Serial.print("->Frequency R=");
         Serial.println(g_count); // The number of pulses output by the TCS3200 when the red light in 1s passes through the filter.
         g_array[0] = g_count;  // The number of pulses output by the TCS3200 when the red light in 1s is passed through the filter

         if(g_SF[0] == 0) {
          g_SF[0] = 255.0/ g_array[0];     // Red light scale factor
          Serial.print("R reference value: ");
          Serial.println(g_SF[0]);
         } else {
          Serial.print("Scaled R: ");
          Serial.println(int(g_array[0] * g_SF[0]));
         }
         
         TSC_WB(HIGH, HIGH);   // Select the mode that lets green light pass through the filter
         break;
    case 2:
         Serial.print("->Frequency G=");
         Serial.println(g_count);  // The number of pulses output by the TCS3200 when the green light in 1s passes through the filter.
         g_array[1] = g_count;   // The number of pulses output by the TCS3200 when the green light in 1s is passed through the filter

         if(g_SF[1] == 0) {
          g_SF[1] = 255.0/ g_array[1] ;   // Green light scale factor
          Serial.print("G reference value: ");
          Serial.println(g_SF[1]);
         } else {
          Serial.print("Scaled G: ");
          Serial.println(int(g_array[1] * g_SF[1]));
         }
         
         TSC_WB(LOW, HIGH);      // Select the mode that lets blue light pass through the filter
         break;
    case 3:
         Serial.print("->Frequency B=");
         Serial.println(g_count); // The number of pulses output by the TCS3200 when the blue light in 1s passes through the filter.
         Serial.println("->WB End");
         g_array[2] = g_count;// The number of pulses output by the TCS3200 when the blue light in 1s is passed through the filter

         if(g_SF[2] == 0) {
          g_SF[2] = 255.0/ g_array[2] ;  // Blue light scale factor
          Serial.print("B reference value: ");
          Serial.println(g_SF[2]);
         } else {
          Serial.print("Sacled B: ");
          Serial.println(int(g_array[2] * g_SF[2]));
         }
         
         // TSC_WB(HIGH, LOW);  // Select the mode that no light pass through the filter
         g_flag = 0;
         TSC_WB(LOW, LOW);  // Select the mode that lets red light pass through the filter
         break;
   default:
         g_flag = 0;
         g_count = 0; // Count value is cleared
         break;
  }
}

// Set the flag for how to process data when the red, green, and blue lights in the reflected light pass through the filter respectively.
//This function is called by TSC_Callback( )
void TSC_WB(int Level0, int Level1)      
{
  g_count = 0; // Count value is cleared
  g_flag ++;  // Output signal count flag
  TSC_FilterColor(Level0, Level1); //flitter mode
}
  
void setup()
{
  TSC_Init();
  Serial.begin(9600); // Set baud rate
  timer.every(500, TSC_Callback);
  attachInterrupt(digitalPinToInterrupt(OUT), TSC_Count, RISING); // Set the upper edge of the TCS3200 output signal to trigger the interrupt. The interrupt call function is TSC_Count().
}
 
void loop()
{
   timer.tick();
}

